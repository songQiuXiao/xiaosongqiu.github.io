<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"songqiuxiao.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="˙Ⱉ˙最近的工作一直在使用React，已经差不多五个月了，想给自己写些对react的一些思考和总结。也记录一下当初刚上手时的疑惑，方便后续自己回顾。网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，怀揣着敬畏之心，发现其实也没那么的复杂嘛…">
<meta property="og:type" content="article">
<meta property="og:title" content="关于React˙Ⱉ˙">
<meta property="og:url" content="https:&#x2F;&#x2F;songqiuxiao.github.io&#x2F;2020&#x2F;01&#x2F;07&#x2F;about-react&#x2F;index.html">
<meta property="og:site_name" content="宋秋晓">
<meta property="og:description" content="˙Ⱉ˙最近的工作一直在使用React，已经差不多五个月了，想给自己写些对react的一些思考和总结。也记录一下当初刚上手时的疑惑，方便后续自己回顾。网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，怀揣着敬畏之心，发现其实也没那么的复杂嘛…">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https:&#x2F;&#x2F;songqiuxiao.github.io&#x2F;2020&#x2F;01&#x2F;07&#x2F;about-react&#x2F;1.jpg">
<meta property="article:published_time" content="2020-01-07T07:19:08.000Z">
<meta property="article:modified_time" content="2020-01-21T03:07:27.688Z">
<meta property="article:author" content="宋秋晓">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;songqiuxiao.github.io&#x2F;2020&#x2F;01&#x2F;07&#x2F;about-react&#x2F;1.jpg">

<link rel="canonical" href="https://songqiuxiao.github.io/2020/01/07/about-react/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>关于React˙Ⱉ˙ | 宋秋晓</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">宋秋晓</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">You are the JavaScript in my HTML</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://songqiuxiao.github.io/2020/01/07/about-react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="宋秋晓">
      <meta itemprop="description" content="月亮是我抛的硬币🌙 两边都是梦见你">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="宋秋晓">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          关于React˙Ⱉ˙
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-07 15:19:08" itemprop="dateCreated datePublished" datetime="2020-01-07T15:19:08+08:00">2020-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-21 11:07:27" itemprop="dateModified" datetime="2020-01-21T11:07:27+08:00">2020-01-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>˙Ⱉ˙最近的工作一直在使用React，已经差不多五个月了，想给自己写些对react的一些思考和总结。也记录一下当初刚上手时的疑惑，方便后续自己回顾。<br>网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，怀揣着敬畏之心，发现其实也没那么的复杂嘛…</p>
<a id="more"></a>
<h4 id="为什么要引入-React"><a href="#为什么要引入-React" class="headerlink" title="为什么要引入 React"></a>为什么要引入 React</h4><p>在写 React 的时候，你可能会写类似这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...other code</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一颗小松球˙Ⱉ˙<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头一次接触的时候肯定疑惑过，下面的代码都没有用到 React，为什么要引入 React 呢？</p>
<p>如果你把 import React from ‘react’ 删掉，还会报下面这样的错误：<br><img src="/2020/01/07/about-react/1.jpg" alt="img"><br>那么究竟是哪里用到了这个 React，导致我们引入 React 会报错呢，不懂这个原因，那么就是 JSX 没有搞得太明白。</p>
<p>你可以讲上面的代码(忽略导入语句)放到在线 babel 里进行转化一下，发现 babel 会把上面的代码转化成:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...other code</span></span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">"h1"</span>, <span class="literal">null</span>, <span class="string">"我是一颗小松球˙Ⱉ˙"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为从本质上讲，JSX 只是为 <code>React.createElement(component, props, ...children)</code> 函数提供的语法糖。</p>
<h4 id="为什么要用-className-而不用-class"><a href="#为什么要用-className-而不用-class" class="headerlink" title="为什么要用 className 而不用 class"></a>为什么要用 <code>className</code> 而不用 <code>class</code></h4><ul>
<li>设计理念<br>这个其实是因为React 一开始的理念是想与浏览器的 DOM API 保持一直而不是 HTML，因为 JSX 是 JS 的扩展，而不是用来代替 HTML 的，这样会和元素的创建更为接近。在元素上设置 class 需要使用 className 这个 API：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>)</span><br><span class="line">element.className = <span class="string">"hello"</span></span><br></pre></td></tr></table></figure></li>
<li>关键字不支持<br>浏览器问题，ES5 之前，在对象中不能使用保留字。以下代码在 IE8 中将会抛出错误：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line"> attributes: &#123;</span><br><span class="line">   class: "hello"</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
解构问题，当你在解构属性的时候，如果分配一个 class 变量会出问题：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="class"><span class="keyword">class</span> &#125; </span>= &#123; <span class="attr">class</span>: <span class="string">'foo'</span> &#125; <span class="comment">// Uncaught SyntaxError: Unexpected token &#125;</span></span><br><span class="line"><span class="keyword">const</span> &#123; className &#125; = &#123; <span class="attr">className</span>: <span class="string">'foo'</span> &#125; </span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">class</span>: className &#125; = &#123; <span class="attr">class</span>: <span class="string">'foo'</span> &#125;</span><br></pre></td></tr></table></figure>
其他讨论可继续深度搜索：『有趣的话题，为什么jsx用className而不是class』</li>
</ul>
<h4 id="为什么属性要用小驼峰"><a href="#为什么属性要用小驼峰" class="headerlink" title="为什么属性要用小驼峰"></a>为什么属性要用小驼峰</h4><blockquote>
<p>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。<br><cite><a href="https://react.docschina.org/docs/introducing-jsx.html" target="_blank" rel="noopener">来自 JSX 简介</a></cite></p>
</blockquote>
<h4 id="为什么-constructor-里要调用-super-和传递-props"><a href="#为什么-constructor-里要调用-super-和传递-props" class="headerlink" title="为什么 constructor 里要调用 super 和传递 props"></a>为什么 constructor 里要调用 super 和传递 props</h4><p>这是官网的一段代码，具体见：<a href="https://react.docschina.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">状态(State) 和 生命周期</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);<span class="comment">// ˙Ⱉ˙咩啊？</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而且有这么一段话，不仅让我们调用 super 还要把 props 传递进去，但是没有告诉我们为什么要这么做。<br>不知道你有没有疑惑过为什么要调用 super 和传递 props，接下来我们来解开谜题吧。</p>
<h5 id="为什么要调用-super"><a href="#为什么要调用-super" class="headerlink" title="为什么要调用 super"></a>为什么要调用 <code>super</code></h5><p>其实这不是 React 的限制，这是 JavaScript 的限制，在构造函数里如果要调用 <code>this</code>，那么提前就要调用 super，在 React 里，我们常常会在构造函数里初始化 <code>state，this.state = xxx</code> ，所以需要调用 <code>super</code>。</p>
<h5 id="为什么要传递-props"><a href="#为什么要传递-props" class="headerlink" title="为什么要传递 props`"></a>为什么要传递 props`</h5><p>你可能以为必须给 <code>super</code> 传入 <code>props</code>，否则 <code>React.Component</code> 就没法初始化 <code>this.props</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，如果你不小心漏传了 props，直接调用了 super()，你仍然可以在 render 和其他方法中访问 this.props（不信的话可以试试嘛˙Ⱉ˙）。</p>
<p>为啥这样也行？因为React 会在构造函数被调用之后，会把 props 赋值给刚刚创建的实例对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> YourComponent(props);</span><br><span class="line">instance.props = props;</span><br></pre></td></tr></table></figure>
<p><code>props</code> 所以说不传也能用，是有原因的。</p>
<p>但这意味着你在使用 React 时，可以用 <code>super()</code> 代替 <code>super(props)</code> 了么？</p>
<p>那还是不行的，不然官网也不会建议你调用 <code>props</code> 了，虽然 React 会在构造函数运行之后，为 <code>this.props</code> 赋值，但在 <code>super()</code> 调用之后与构造函数结束之前， <code>this.props</code> 仍然是没法用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inside React</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside your code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(); <span class="comment">// 😬 忘了传入 props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props); <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// 😬 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要是构造函数中调用了某个访问 <code>props</code>的方法，那这个 bug 就更难定位了。因此强烈建议始终使用<code>super(props)</code>，即使这不是必须的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props); <span class="comment">// ✅ We passed props</span></span><br><span class="line">    <span class="built_in">console</span>.log(props); <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// ✅ &#123;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码确保 <code>this.props</code> 始终是有值的。</p>
<p>如果你想避免以上的问题，你可以通过<code>class</code>属性提案 来简化代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么组件用大写开头"><a href="#为什么组件用大写开头" class="headerlink" title="为什么组件用大写开头"></a>为什么组件用大写开头</h4><p>前面以及说过了，JSX 是为 <code>React.createElement(component, props, …children)</code> 提供的语法糖，component 的类型是：string/ReactClass type，我们具体看一下在什么情况下会用到 string 类型，什么情况下用到 ReactClass type 类型</p>
<ul>
<li>string 类型react会觉得他是一个原生dom节点</li>
<li>ReactClass type 类型 自定义组件</li>
</ul>
<p>例如（string）：在 jsx 中我们写一个</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>转换为js的时候就变成了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>例如（ReactClass type）：在jsx中我们写一个</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDiv</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;&lt;div&gt;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;MyDiv&gt;&lt;/MyDiv&gt;</span><br></pre></td></tr></table></figure>
<p>转换为js的时候就变成了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDiv</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.createElement(MyDiv, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>上边的例子中如果将MyDiv中的首字母小写，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myDiv</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;&lt;div&gt;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;myDiv&gt;&lt;/myDiv&gt;</span><br></pre></td></tr></table></figure>
<p>转换为 js 的时候就变成了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyDiv</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.createElement(<span class="string">"myDiv"</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>由于找不到 myDiv 这个 dom，所以就会报错。</p>
<h4 id="为什么调用方法要-bind-this"><a href="#为什么调用方法要-bind-this" class="headerlink" title="为什么调用方法要 bind this"></a>为什么调用方法要 <code>bind this</code></h4><p><strong>首先，你需要深刻的理解 JavaScript 中的 <code>this</code></strong></p>
<p>相信刚写 React 的时候，很多朋友可能会写类似这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">xxx</span>: aaa &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>发现会报 <code>this</code> 是 <code>undefined</code> 的错，然后可能对事件处理比较疑惑，然后去看官网的事件处理有下面一段话：</p>
<p>你必须谨慎对待 JSX 回调函数中的 <code>this</code>，在 JavaScript 中，class 的方法默认不会绑定<code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。<br>这并不是 React 特有的行为；这其实与 JavaScript 函数工作原理有关。通常情况下，如果你没有在方法后面添加 <code>()</code>，例如 <code>onClick={this.handleClick}</code>，你应该为这个方法绑定 <code>this</code>。<br>然后你看了官网的例子和建议之后，知道需要为事件处理函数绑定 <code>this</code> 就能解决，像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">xxx</span>: aaa &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是可能你没有去思考过为什么需要 <code>bind this</code>？如果你不能理解的话，那就还是 js 的基础没有打好。</p>
<h5 id="React-是如何处理事件的？"><a href="#React-是如何处理事件的？" class="headerlink" title="React 是如何处理事件的？"></a>React 是如何处理事件的？</h5><p>咱们先来了解一下 React 是如何处理事件的。</p>
<p>React 的事件是合成事件， 内部原理非常复杂，这里只把关键性，可以用来解答这个问题的原理部分进行介绍</p>
<p>上篇已经说过，jsx 实际上是 <code>React.createElement(component, props, …children)</code> 函数提供的语法糖，那么这段 jsx 代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">   Click me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>会被转化为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(<span class="string">"button"</span>, &#123;</span><br><span class="line">    onClick: <span class="keyword">this</span>.handleClick</span><br><span class="line">&#125;, <span class="string">"Click me"</span>)</span><br></pre></td></tr></table></figure>
<p>了解了上面的，然后简单的理解 react 如何处理事件的，React 在组件加载(mount)和更新(update)时，将事件通过 <code>addEventListener</code>  统一注册到 <code>document 上</code>，然后会有一个事件池存储了所有的事件，当事件触发的时候，通过 <code>dispatchEvent</code> 进行事件分发。</p>
<p>所以你可以简单的理解为，最终 <code>this.handleClick</code> 会作为一个回调函数调用。</p>
<p>理解了这个，然后再来看看回调函数为什么就会丢失 <code>this</code>。</p>
<h5 id="this-简单回顾"><a href="#this-简单回顾" class="headerlink" title="this 简单回顾"></a><code>this</code> 简单回顾</h5><blockquote>
<p>在函数内部，<code>this</code>的值取决于函数被调用的方式。</p>
</blockquote>
<p>通过上面对事件处理的介绍，来模拟一下在类组件的 render 函数中， 有点类似于做了这样的操作:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    sayThis () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 这里的 `this` 指向谁？</span></span><br><span class="line">    &#125;</span><br><span class="line">    exec (cb) &#123;</span><br><span class="line">        cb();</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">this</span>.exec(<span class="keyword">this</span>.sayThis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.render(); <span class="comment">// 输出结果是什么？</span></span><br></pre></td></tr></table></figure>
<p>你会发现最终结果输出的是 <code>undefined</code>，那么我觉得你也可以理解为什么需要 <code>bind this</code> 了。（就是cb调用的时候，把this搞丢惹˙Ⱉ˙）</p>
<p>那么你可能会问：为什么React没有自动的把 <code>bind</code> 集成到 <code>render</code> 方法中呢?在 <code>exec</code> 调用回调的时候绑定进去，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    sayThis () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 这里的 `this` 指向谁？</span></span><br><span class="line">    &#125;</span><br><span class="line">    exec (cb) &#123;</span><br><span class="line">        cb().bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">        <span class="keyword">this</span>.exec(<span class="keyword">this</span>.sayThis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.render(); <span class="comment">// 输出结果是什么？</span></span><br></pre></td></tr></table></figure>
<p><strong>因为 <code>render</code> 多次调用每次都要 <code>bind</code> 会影响性能，所以官方建议你自己在 <code>constructor</code> 中手动 <code>bind</code> 达到性能优化。</strong></p>
<h5 id="四种事件处理对比"><a href="#四种事件处理对比" class="headerlink" title="四种事件处理对比"></a>四种事件处理对比</h5><p>对于事件处理的写法也有好几种，咱们来进行对比一下：</p>
<ol>
<li>直接 bind this 型<br>就是像文章开始的那样，直接在事件那里 bind this<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">xxx</span>: aaa &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：写起来顺手，一口气就能把这个逻辑写完，不用移动光标到其他地方。<br><strong>缺点</strong>：性能不太好，这种方式跟 react 内部帮你 bind 一样的，每次 render 都会进行 bind，而且如果有两个元素的事件处理函数式同一个，也还是要进行 bind，这样会多写点代码，而且进行两次 bind，性能不是太好。(不过其实这点性能往往不会是性能瓶颈的地方，如果你觉得顺手，这样写完全没问题)</p>
<ol start="2">
<li>constuctor 手动 bind 型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constuctor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">xxx</span>: aaa &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：相比于第一种性能更好，因为构造函数只执行一次，那么只会 bind 一次，而且如果有多个元素都需要调用这个函数，也不需要重复 bind，基本上解决了第一种的两个缺点。<br><strong>缺点</strong>：没有明显缺点，硬要说的话就是太丑了，然后不顺手。</p>
<ol start="3">
<li>箭头函数型<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">xxx</span>: aaa &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：顺手，好看。<br><strong>缺点</strong>：每次 render 都会重复创建函数，性能会差一点。</p>
<ol start="4">
<li>public class fields 型<br>这种 class fields还处于实验阶段，貌似目前还没有被纳入标准<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">xxx</span>: aaa &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优点</strong>：好看，性能好。<br><strong>缺点</strong>：没有明显缺点，如果硬要说可能就是要多装一个 babel 插件来支持这种语法。</p>
<h4 id="为什么要-setState，而不是直接-this-state-xx-oo"><a href="#为什么要-setState，而不是直接-this-state-xx-oo" class="headerlink" title="为什么要 setState，而不是直接 this.state.xx = oo"></a>为什么要 <code>setState</code>，而不是直接 <code>this.state.xx = oo</code></h4><p>如果从 vue 转到 React 可能会有这种疑问，因为 vue 修改状态都是直接改的。</p>
<p>如果我们了解 <code>setState</code>的原理的话，可能就能解答这个问题了，<code>setState</code> 做的事情不仅仅只是修改了 <code>this.state</code> 的值，另外最重要的是它会触发 React 的更新机制，会进行 diff ，然后将 patch 部分更新到真实 dom 里。</p>
<p>如果你直接 <code>this.state.xx == oo</code> 的话，<code>state</code> 的值确实会改，但是改了不会触发 UI 的更新，那就不是数据驱动了。</p>
<p>那为什么 Vue 直接修改 <code>data</code> 可以触发 UI 的更新呢？因为 Vue 在创建 UI 的时候会把这些 <code>data</code> 给收集起来，并且在这些 <code>data</code> 的访问器属性 <code>setter</code> 进行了重写，在这个重写的方法里会去触发 UI 的更新。</p>
<h4 id="setState-是同步还是异步相关问题"><a href="#setState-是同步还是异步相关问题" class="headerlink" title="setState 是同步还是异步相关问题"></a><code>setState</code> 是同步还是异步相关问题</h4><ol>
<li><p><code>setState</code> 是同步还是异步？<br>我的回答是执行过程代码同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，所以表现出来有时是同步，有时是“异步”。</p>
</li>
<li><p>何时是同步，何时是异步呢？<br>只在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout/setInterval</code> 等原生 API 中都是同步的。简单的可以理解为被 React 控制的函数里面就会表现出“异步”，反之表现为同步。</p>
</li>
<li><p>那为什么会出现异步的情况呢？<br>为了做性能优化，将 <code>state</code> 的更新延缓到最后批量合并再去渲染对于应用的性能优化是有极大好处的，如果每次的状态改变都去重新渲染真实 dom，那么它将带来巨大的性能消耗。</p>
</li>
<li><p>那如何在表现出异步的函数里可以准确拿到更新后的 <code>state</code> 呢？<br>通过第二个参数 <code>setState(partialState, callback)</code> 中的 <code>callback</code> 拿到更新后的结果。<br>或者可以通过给 <code>setState</code> 传递函数来表现出同步的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">val</span>: newVal &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>那表现出异步的原理是怎么样的呢？<br>在 React 的 <code>setState</code> 函数实现中，会根据 <code>isBatchingUpdates</code>(默认是 false) 变量判断是否直接更新 <code>this.state</code> 还是放到队列中稍后更新。然后有一个 <code>batchedUpdate</code> 函数，可以修改 <code>isBatchingUpdates</code> 为 <code>true，当</code> React 调用事件处理函数之前，或者生命周期函数之前就会调用 <code>batchedUpdate</code> 函数，这样的话，<code>setState</code> 就不会同步更新 <code>this.state</code>，而是放到更新队列里面后续更新。<br>这样你就可以理解为什么原生事件和 <code>setTimeout/setinterval</code> 里面调用 <code>this.state</code> 会同步更新了吧，因为通过这些函数调用的 React 没办法去调用 <code>batchedUpdate</code> 函数将 <code>isBatchingUpdates</code> 设置为 <code>true</code>，那么这个时候 <code>setState</code> 的时候默认就是 <code>false</code>，那么就会同步更新。</p>
</li>
</ol>
<p>最后<br><code>setState</code> 是 React 非常重要的一个方法，值得大家好好去研究一下他的原理。</p>
<p>参考文章</p>
<p>React 中为什么要 bind this<br>《React 状态管理与同构实践》</p>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/18/json/" rel="prev" title="通过需求学习JSON.stringify()">
      <i class="fa fa-chevron-left"></i> 通过需求学习JSON.stringify()
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/02/09/about-docker/" rel="next" title="前端领域的 Docker">
      前端领域的 Docker <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要引入-React"><span class="nav-number">1.</span> <span class="nav-text">为什么要引入 React</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要用-className-而不用-class"><span class="nav-number">2.</span> <span class="nav-text">为什么要用 className 而不用 class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么属性要用小驼峰"><span class="nav-number">3.</span> <span class="nav-text">为什么属性要用小驼峰</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么-constructor-里要调用-super-和传递-props"><span class="nav-number">4.</span> <span class="nav-text">为什么 constructor 里要调用 super 和传递 props</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要调用-super"><span class="nav-number">4.1.</span> <span class="nav-text">为什么要调用 super</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要传递-props"><span class="nav-number">4.2.</span> <span class="nav-text">为什么要传递 props&#96;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么组件用大写开头"><span class="nav-number">5.</span> <span class="nav-text">为什么组件用大写开头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么调用方法要-bind-this"><span class="nav-number">6.</span> <span class="nav-text">为什么调用方法要 bind this</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#React-是如何处理事件的？"><span class="nav-number">6.1.</span> <span class="nav-text">React 是如何处理事件的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#this-简单回顾"><span class="nav-number">6.2.</span> <span class="nav-text">this 简单回顾</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四种事件处理对比"><span class="nav-number">6.3.</span> <span class="nav-text">四种事件处理对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要-setState，而不是直接-this-state-xx-oo"><span class="nav-number">7.</span> <span class="nav-text">为什么要 setState，而不是直接 this.state.xx &#x3D; oo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setState-是同步还是异步相关问题"><span class="nav-number">8.</span> <span class="nav-text">setState 是同步还是异步相关问题</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="宋秋晓"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">宋秋晓</p>
  <div class="site-description" itemprop="description">月亮是我抛的硬币🌙 两边都是梦见你</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">宋秋晓</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  1
  <script type="text/javascript" src="/js/love.js"></script>
</body>
</html>
